
#pragma once
#include <pg/pg_Result.hpp>
#include <unicorn/unicorn.h>

namespace pg::emu::cpu {

    namespace result {

        PG_RESULT_NAMESPACE_DEFINE_MODULE(505);

        constexpr u32 UnicornErrorCodeBase = 1000;
        #define PG_EMU_CPU_RESULT_DEFINE_UNICORN(uc_err_val) PG_RESULT_NAMESPACE_DEFINE(Unicorn_ ## uc_err_val, UnicornErrorCodeBase + static_cast<u32>(uc_err_val))

        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_NOMEM);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_ARCH);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_HANDLE);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_MODE);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_VERSION);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_READ_UNMAPPED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_WRITE_UNMAPPED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_FETCH_UNMAPPED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_HOOK);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_INSN_INVALID);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_MAP);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_WRITE_PROT);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_READ_PROT);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_FETCH_PROT);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_ARG);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_READ_UNALIGNED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_WRITE_UNALIGNED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_FETCH_UNALIGNED);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_HOOK_EXIST);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_RESOURCE);
        PG_EMU_CPU_RESULT_DEFINE_UNICORN(UC_ERR_EXCEPTION);

        #undef PG_EMU_CPU_RESULT_DEFINE_UNICORN

        inline constexpr Result ConvertFromUnicornErrorCode(const uc_err err) {
            if(err == UC_ERR_OK) {
                return ResultSuccess;
            }
            return Result(Module, UnicornErrorCodeBase + static_cast<u32>(err));
        }

    }

}